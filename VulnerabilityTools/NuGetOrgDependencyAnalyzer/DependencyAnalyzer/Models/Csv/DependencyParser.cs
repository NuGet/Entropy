using CsvHelper;
using CsvHelper.Configuration;
using CsvHelper.TypeConversion;
using NuGet.Versioning;
using System.Buffers;
using System.Collections.Immutable;
using System.Text;
using System.Text.Json;

namespace DependencyAnalyzer.Models.Csv
{
    internal class DependencyParser : ITypeConverter
    {
        private static readonly Intermediate.PackageManifests.DependencyList Empty = new()
        {
            Count = 0,
            Dependencies = ImmutableList<Intermediate.PackageManifests.Dependency>.Empty
        };
        private static readonly byte[] PackagesPropertyName = Encoding.UTF8.GetBytes("Packages");
        private static readonly byte[] IdPropertyName = Encoding.UTF8.GetBytes("Id");
        private static readonly byte[] VersionRangePropertyName = Encoding.UTF8.GetBytes("VersionRange");
        private static NuGetVersion Zero = new NuGetVersion(0, 0, 0, 0);

        public object? ConvertFromString(string? text, IReaderRow row, MemberMapData memberMapData)
        {
            var result = Parse(text ?? string.Empty);
            return result;
        }

        public string? ConvertToString(object? value, IWriterRow row, MemberMapData memberMapData)
        {
            throw new NotImplementedException();
        }

        private static Intermediate.PackageManifests.DependencyList Parse(string text)
        {
            if (string.IsNullOrEmpty(text) || text == "[]")
            {
                return Empty;
            }

            var buffer = ArrayPool<byte>.Shared.Rent(64 * 1024);
            try
            {
                var bytes = Encoding.UTF8.GetBytes(text, 0, text.Length, buffer, 0);
                if (bytes >= buffer.Length)
                {
                    throw new NotSupportedException();
                }

                var span = buffer.AsSpan(0, bytes);
                var reader = new Utf8JsonReader(span);
                Intermediate.PackageManifests.DependencyList dependencies = ReadDependencyGroups(ref reader);

                return dependencies;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                buffer.AsSpan().Clear();
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }

        private static Intermediate.PackageManifests.DependencyList ReadDependencyGroups(ref Utf8JsonReader reader)
        {
            if (!reader.Read()) { throw new JsonException(); }
            if (reader.TokenType != JsonTokenType.StartArray) { throw new JsonException(); }

            // For this analysis, we don't care about different target frameworks, but we do care if
            // different target frameworks have different versions of the same package.
            HashSet<Intermediate.PackageManifests.Dependency> dependencies = new();

            if (!reader.Read()) { throw new JsonException(); }
            while (reader.TokenType != JsonTokenType.EndArray)
            {
                ReadDependencyGroup(ref reader, dependencies);
                if (!reader.Read()) { throw new JsonException(); }
            }

            if (dependencies.Count == 0)
            {
                return Empty;
            }
            return new Intermediate.PackageManifests.DependencyList
            {
                Count = dependencies.Count,
                Dependencies = dependencies.OrderBy(d => d.Id).ToImmutableList()
            };
        }

        private static void ReadDependencyGroup(ref Utf8JsonReader reader, HashSet<Intermediate.PackageManifests.Dependency> dependencies)
        {
            if (reader.TokenType != JsonTokenType.StartObject) { throw new JsonException(); }
            if (!reader.Read()) { throw new JsonException(); }
            while (reader.TokenType != JsonTokenType.EndObject)
            {
                if (reader.TokenType != JsonTokenType.PropertyName) { throw new JsonException(); }
                if (!reader.ValueTextEquals(PackagesPropertyName))
                {
                    // We aren't collecting packages per target framework, so skip any property that isn't
                    // the packages list.
                    if (!reader.TrySkip()) { throw new JsonException(); }
                }
                else
                {
                    // packages object
                    if (!reader.Read()) { throw new JsonException(); }
                    ReadDependencies(ref reader, dependencies);
                }
                if (!reader.Read()) { throw new JsonException(); }
            }
        }

        private static void ReadDependencies(ref Utf8JsonReader reader, HashSet<Intermediate.PackageManifests.Dependency> dependencies)
        {
            if (reader.TokenType != JsonTokenType.StartArray) { throw new JsonException(); }
            if (!reader.Read()) { throw new JsonException(); }
            while (reader.TokenType != JsonTokenType.EndArray)
            {
                var dependency = ReadDependency(ref reader);
                dependencies.Add(dependency);

                if (!reader.Read()) { throw new JsonException(); }
            }
        }

        private static Intermediate.PackageManifests.Dependency ReadDependency(ref Utf8JsonReader reader)
        {
            string? id = null, version = null;

            if (reader.TokenType != JsonTokenType.StartObject) { throw new JsonException(); }
            if (!reader.Read()) { throw new JsonException(); }
            while (reader.TokenType != JsonTokenType.EndObject)
            {
                if (reader.TokenType != JsonTokenType.PropertyName) { throw new JsonException(); }
                if (reader.ValueTextEquals(IdPropertyName))
                {
                    if (!reader.Read()) { throw new JsonException(); }
                    id = reader.GetString() ?? throw new JsonException();
                }
                else if (reader.ValueTextEquals(VersionRangePropertyName))
                {
                    if (!reader.Read()) { throw new JsonException(); }
                    var versionRangeText = reader.GetString() ?? throw new JsonException();
                    var versionRange = VersionRange.Parse(versionRangeText);
                    version = versionRange.MinVersion?.ToString().ToLowerInvariant() ?? "0.0.0";
                }
                else
                {
                    if (!reader.TrySkip()) { throw new JsonException(); }
                }
                if (!reader.Read()) { throw new JsonException(); }
            }

            if (id is null || version is null)
            {
                throw new JsonException();
            }

            var dependency = new Intermediate.PackageManifests.Dependency
            {
                Id = id,
                Version = version
            };
            return dependency;
        }
    }
}
