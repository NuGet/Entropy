using Azure.Identity;
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Threading.Tasks.Dataflow;

namespace DependencyAnalyzer;

internal class Downloader
{
    public State State { get; private set; }

    private DirectoryInfo _dataDirectory;

    public Downloader(State state, DirectoryInfo dataDirectory)
    {
        State = state ?? throw new ArgumentNullException(nameof(state));
        if (string.IsNullOrEmpty(state.NuGetInsightsUrl))
        {
            throw new ArgumentException(paramName: nameof(state.NuGetInsightsUrl),
                message: $"state.{nameof(state.NuGetInsightsUrl)} must be set");
        }

        _dataDirectory = dataDirectory ?? throw new ArgumentNullException(nameof(dataDirectory));
    }

    public async Task GetAllData()
    {
        var identity = new DefaultAzureCredential();
        var blobService = new BlobServiceClient(new Uri(State.NuGetInsightsUrl), identity);

        if (State.Files is null || !(await VerifyDownloadsAsync(blobService, quick: true)))
        {
            var packageManifestFiles = await GetFilesInContainerAsync("packagemanifests", blobService);
            var packageDeprecationFiles = await GetFilesInContainerAsync("packagedeprecations", blobService);
            var packageDownloadsFiles = await GetFilesInContainerAsync("packagedownloads", blobService);
            var packageVersionsFiles = await GetFilesInContainerAsync("packageversions", blobService);

            var fileGroups = new FileGroups
            {
                PackageManifests = packageManifestFiles,
                PackageDeprecations = packageDeprecationFiles,
                PackageDownloads = packageDownloadsFiles,
                PackageVersions = packageVersionsFiles,
            };

            State = State with
            {
                Files = fileGroups,
            };
            State.Save(_dataDirectory);

            if (!await VerifyDownloadsAsync(blobService, quick: false))
            {
                throw new Exception("Failed to download files");
            }
        }

    }

    private async Task<bool> VerifyDownloadsAsync(BlobServiceClient blobService, bool quick)
    {
        if(State.Files is null)
        {
            throw new ArgumentException("State.Files must be set");
        }

        var options = new ExecutionDataflowBlockOptions()
        {
            MaxDegreeOfParallelism = 8, // max concurrent downloads
            BoundedCapacity = 8, // max queued downloads
        };
        using CancellationTokenSource cts = new();
        TransformBlock<(string container, BlobFile file, BlobContainerClient client, bool quick), bool> ValidateFileDownloadedBlock = new(ValidateFileDownloadedAsync, options);
        ActionBlock<bool> cancelWhenFailedBlock = new((success) =>
        {
            if (!success)
            {
                cts.Cancel();
                ValidateFileDownloadedBlock.Complete();
            }
        });
        using var blockLink = ValidateFileDownloadedBlock.LinkTo(cancelWhenFailedBlock, new DataflowLinkOptions { PropagateCompletion = true });

        await SendFilesAsync(ValidateFileDownloadedBlock, blobService, quick, cts.Token);
        ValidateFileDownloadedBlock.Complete();
        await cancelWhenFailedBlock.Completion;

        if (cts.IsCancellationRequested)
        {
            return false;
        }

        return true;

        async Task<bool> SendFilesAsync(
            ITargetBlock<(string, BlobFile, BlobContainerClient, bool)> queue, 
            BlobServiceClient client, 
            bool quick, 
            CancellationToken cancellationToken)
        {
            FileGroups groups = State.Files!;

            bool success = await SendFilesAsync(App.Containers.PackageManifests, groups.PackageManifests, queue, client, quick, cancellationToken)
                && await SendFilesAsync(App.Containers.PackageDeprecations, groups.PackageDeprecations, queue, client, quick, cancellationToken)
                && await SendFilesAsync(App.Containers.PackageDownloads, groups.PackageDownloads, queue, client, quick, cancellationToken)
                && await SendFilesAsync(App.Containers.PackageVersions, groups.PackageVersions, queue, client, quick, cancellationToken);
            return success;

            async Task<bool> SendFilesAsync(
                string container, 
                ImmutableList<BlobFile> files, 
                ITargetBlock<(string, BlobFile, BlobContainerClient, bool)> queue,
                BlobServiceClient client,
                bool quick,
                CancellationToken cancellationToken)
            {
                var containerClient = client.GetBlobContainerClient(container);

                foreach (var file in files)
                {
                    await queue.SendAsync((container, file, containerClient, quick), cancellationToken);
                    if (cancellationToken.IsCancellationRequested)
                    {
                        return false;
                    }
                }

                List<string> expectedFiles = new(files.Count);
                if (Path.AltDirectorySeparatorChar != Path.DirectorySeparatorChar)
                {
                    expectedFiles.AddRange(files.Select(f => {
                        var relativePath = f.Name.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
                        var absolutePath = App.GetInsightsFileName(_dataDirectory.FullName, container, relativePath);
                        return absolutePath;
                    }));
                }
                else
                {
                    expectedFiles.AddRange(files.Select(f => App.GetInsightsFileName(_dataDirectory.FullName, container, f.Name)));
                }

                List<string> toDelete = new();
                foreach (var file in Directory.EnumerateFiles(App.GetInsightsDirectory(_dataDirectory.FullName, container), "*", SearchOption.AllDirectories))
                {
                    if (!expectedFiles.Contains(file))
                    {
                        toDelete.Add(file);
                    }
                }

                foreach (var file in toDelete)
                {
                    File.Delete(file);
                }

                return true;
            }
        }
    }

    private async Task<bool> ValidateFileDownloadedAsync((string container, BlobFile file, BlobContainerClient containerClient, bool quick) input)
    {
        string directory = App.GetInsightsDirectory(_dataDirectory.FullName, input.container);
        if (!Directory.Exists(directory))
        {
            try
            {
                Directory.CreateDirectory(directory);
            }
            catch (IOException)
            {
                // two threads probably tried to create the directory at the same time
            }
        }

        var fileName = Path.Combine(directory, input.file.Name);
        var fileInfo = new FileInfo(fileName);
        if (fileInfo.Exists)
        {
            if (fileInfo.Length == input.file.Length
                && fileInfo.LastWriteTimeUtc == input.file.LastModified.ToUniversalTime()
                && Md5Matches(fileName, input.file.MD5))
            {
                return true;
            }
            else
            {
                if (input.quick)
                {
                    return false;
                }
            }
        }

        var blobFile = input.containerClient.GetBlobClient(input.file.Name);
        var options = new BlobOpenReadOptions(false)
        {
            Conditions = new BlobRequestConditions()
            {
                IfMatch = new Azure.ETag(input.file.ETag)
            }
        };
        Console.WriteLine("Downloading " + blobFile.Uri.OriginalString);
        using (await blobFile.OpenReadAsync(options))
        {
            using (var fileStream = File.OpenWrite(fileName))
            {
                await blobFile.DownloadToAsync(fileStream, CancellationToken.None);
                fileStream.SetLength(fileStream.Position);
                Debug.Assert(fileStream.Length == input.file.Length);
            }
            File.SetLastWriteTimeUtc(fileName, input.file.LastModified.UtcDateTime);
        }

        return true;
    }

    private static bool Md5Matches(string fileName, string expectedMd5)
    {
        using var md5 = MD5.Create();
        using var fileStream = File.OpenRead(fileName);
        var hash = md5.ComputeHash(fileStream);
        string actualMd5 = Convert.ToHexString(hash);

        return expectedMd5.Equals(actualMd5, StringComparison.OrdinalIgnoreCase);
    }

    private async Task<ImmutableList<BlobFile>> GetFilesInContainerAsync(string containerName, BlobServiceClient serviceClient)
    {
        var packageManifestsContainer = serviceClient.GetBlobContainerClient(containerName);

        List<BlobFile> files = new();

        var blobs = packageManifestsContainer.GetBlobsAsync();
        await foreach (var blob in blobs)
        {
            var name = blob.Name;
            var md5 = Convert.ToHexString(blob.Properties.ContentHash);
            var lastModified = blob.Properties.LastModified;
            var length = blob.Properties.ContentLength;
            var etag = blob.Properties.ETag;

            if (!lastModified.HasValue || !length.HasValue || !etag.HasValue )
            {
                throw new Exception("Unexpected");
            }

            var blobFile = new BlobFile
            {
                Name = name,
                MD5 = md5,
                LastModified = lastModified.Value,
                Length = length.Value,
                ETag = etag.Value.ToString()
            };
            files.Add(blobFile);
        }

        return files.ToImmutableList();
    }

}
