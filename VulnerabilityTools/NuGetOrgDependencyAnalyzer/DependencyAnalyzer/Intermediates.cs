using CsvHelper.Configuration;
using CsvHelper;
using System.Globalization;
using System.IO.Compression;
using System.Text.Json;
using System.Collections.Immutable;
using System.Threading.Tasks.Dataflow;

namespace DependencyAnalyzer
{
    internal class Intermediates
    {
        private State state;
        private DirectoryInfo dataDirectory;
        private FileGroups fileGroups;

        public Intermediates(State state, DirectoryInfo dataDirectory)
        {
            this.state = state;
            this.fileGroups = state.Files ?? throw new ArgumentException(paramName: nameof(state), message: "state.Files must not be null");
            this.dataDirectory = dataDirectory;
        }

        public async Task CalculateAsync()
        {
            // some of these use a lot of memory, so run then one at a time, not in parallel.

            if (!PackageDeprecationsUpToDate())
            {
                Console.WriteLine("(Re)Generating package deprecations");
                await CalculatePackageDeprecationsAsync();
            }

            if (!PackageDownloadsUpToDate())
            {
                Console.WriteLine("(Re)Generating package downloads");
                await CalculatePackageDownloadsAsync();
            }

            if (!PackageManifestsUpToDate())
            {
                Console.WriteLine("(Re)Generating package manifests");
                await CalculatePackageManifestsAsync();
            }

            if (!PackageVersionsUpToDate())
            {
                Console.WriteLine("(Re)Generating package versions");
                await CalculatePackageVersionsAsync();
            }
        }

        private bool PackageVersionsUpToDate()
        {
            string fileName = App.GetIntermediatesFileName(dataDirectory.FullName, App.Containers.PackageVersions);
            var equal = TimeStampsAreEqual(fileGroups.PackageVersions, fileName);
            return equal;
        }

        private bool PackageManifestsUpToDate()
        {
            string fileName = App.GetIntermediatesFileName(dataDirectory.FullName, App.Containers.PackageManifests);
            var equal = TimeStampsAreEqual(fileGroups.PackageManifests, fileName);
            return equal;
        }

        private bool PackageDownloadsUpToDate()
        {
            string fileName = App.GetIntermediatesFileName(dataDirectory.FullName, App.Containers.PackageDownloads);
            var equal = TimeStampsAreEqual(fileGroups.PackageDownloads, fileName);
            return equal;
        }

        private bool PackageDeprecationsUpToDate()
        {
            string fileName = App.GetIntermediatesFileName(dataDirectory.FullName, App.Containers.PackageDeprecations);
            var equal = TimeStampsAreEqual(fileGroups.PackageDeprecations, fileName);
            return equal;
        }

        private bool TimeStampsAreEqual(ImmutableList<BlobFile> files, string intermediateFileName)
        {
            DateTimeOffset latestInsightsFileTimeStamp = files.Max(f => f.LastModified);
            DateTimeOffset intermediateResultTimeStamp = File.GetLastWriteTimeUtc(intermediateFileName);
            return latestInsightsFileTimeStamp == intermediateResultTimeStamp;
        }

        private async Task CalculatePackageDeprecationsAsync()
        {
            var result = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);

            await ReadAndTransformCsv<Models.Csv.DeprecatedPackage>(
                dataDirectory.FullName,
                App.Containers.PackageDeprecations,
                new Models.Csv.DeprecatedPackage.CsvMap(),
                fileGroups.PackageDeprecations,
                App.GetIntermediatesFileName(dataDirectory.FullName, App.Containers.PackageDeprecations),
                rows =>
                {
                    foreach (var row in rows)
                    {
                        if (row.Result.Equals(Models.Csv.DeprecatedPackage.NotDeprecatedResult))
                        {
                            continue;
                        }

                        if (!result.TryGetValue(row.Id, out var versions))
                        {
                            versions = new List<string>();
                            result.Add(row.Id, versions);
                        }
                        versions.Add(row.Version);
                    }
                });

            var intermediate = new Models.Intermediate.DeprecatedPackages
            {
                Count = result.Count,
                Packages = result.ToDictionary(kvp => kvp.Key, kvp => new Models.Intermediate.DeprecatedPackages.VersionList
                {
                    Count = kvp.Value.Count,
                    Versions = kvp.Value.ToImmutableList(),
                }).ToImmutableDictionary(StringComparer.OrdinalIgnoreCase),
            };

            await WriteAsync(
                App.GetIntermediatesFileName(dataDirectory.FullName, App.Containers.PackageDeprecations),
                intermediate,
                fileGroups.PackageDeprecations.Max(f => f.LastModified).UtcDateTime);
        }

        private async Task CalculatePackageDownloadsAsync()
        {
            var result = new Dictionary<string, Dictionary<string, Models.Intermediate.PackageDownloads.Downloads>>(StringComparer.OrdinalIgnoreCase);

            await ReadAndTransformCsv<Models.Csv.PackageDownloads>(
                dataDirectory.FullName,
                App.Containers.PackageDownloads,
                new Models.Csv.PackageDownloads.CsvMap(),
                fileGroups.PackageDownloads,
                App.GetIntermediatesFileName(dataDirectory.FullName, App.Containers.PackageDownloads),
                rows =>
                {
                    foreach (var row in rows)
                    {
                        if (!result.TryGetValue(row.Id, out var versions))
                        {
                            versions = new Dictionary<string, Models.Intermediate.PackageDownloads.Downloads>(StringComparer.OrdinalIgnoreCase);
                            result.Add(row.Id, versions);
                        }

                        var downloads = new Models.Intermediate.PackageDownloads.Downloads()
                        {
                            VersionDownloads = row.VersionDownloads,
                            TotalDownloads = row.TotalDownloads,
                        };
                        versions.Add(row.Version, downloads);
                    }
                });

            var intermediate = result.ToDictionary(
                kvp => kvp.Key,
                kvp => new Models.Intermediate.PackageDownloads.VersionList
                {
                    Count = kvp.Value.Count,
                    Versions = kvp.Value.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase)
                });

            var final = new Models.Intermediate.PackageDownloads
            {
                Count = intermediate.Count,
                Packages = intermediate.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase),
            };

            await WriteAsync(
                App.GetIntermediatesFileName(dataDirectory.FullName, App.Containers.PackageDownloads),
                final,
                fileGroups.PackageDownloads.Max(f => f.LastModified).UtcDateTime);
        }

        private async Task CalculatePackageManifestsAsync()
        {
            var result = new Dictionary<string, Dictionary<string, Models.Intermediate.PackageManifests.DependencyList>>(StringComparer.OrdinalIgnoreCase);

            await ReadAndTransformCsv<Models.Csv.PackageManifests>(
                dataDirectory.FullName,
                App.Containers.PackageManifests,
                new Models.Csv.PackageManifests.CsvMap(),
                fileGroups.PackageVersions,
                App.GetIntermediatesFileName(dataDirectory.FullName, App.Containers.PackageManifests),
                rows =>
                {
                    foreach (var row in rows)
                    {
                        if (!result.TryGetValue(row.Id, out var versions))
                        {
                            versions = new Dictionary<string, Models.Intermediate.PackageManifests.DependencyList>(StringComparer.OrdinalIgnoreCase);
                            result.Add(row.Id, versions);
                        }

                        versions.Add(row.Version, row.Dependencies);
                    }
                });

            var intermediate = result.ToDictionary(
                kvp => kvp.Key,
                kvp => new Models.Intermediate.PackageManifests.VersionList
                {
                    Count = kvp.Value.Count,
                    Dependencies = kvp.Value.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase)
                });

            var final = new Models.Intermediate.PackageManifests
            {
                Count = intermediate.Count,
                Packages = intermediate.ToImmutableDictionary(),
            };

            await WriteAsync(
                App.GetIntermediatesFileName(dataDirectory.FullName, App.Containers.PackageManifests),
                final,
                fileGroups.PackageManifests.Max(f => f.LastModified).UtcDateTime);
        }

        private async Task CalculatePackageVersionsAsync()
        {
            var result = new Dictionary<string, Dictionary<string, Models.Intermediate.PackagesVersionInfo.VersionInfo>>(StringComparer.OrdinalIgnoreCase);

            await ReadAndTransformCsv<Models.Csv.PackageVersionInfo>(
                dataDirectory.FullName,
                App.Containers.PackageVersions,
                new Models.Csv.PackageVersionInfo.CsvMap(),
                fileGroups.PackageVersions,
                App.GetIntermediatesFileName(dataDirectory.FullName, App.Containers.PackageVersions),
                rows =>
                {
                    foreach (var row in rows)
                    {
                        if (!result.TryGetValue(row.Id, out var versions))
                        {
                            versions = new Dictionary<string, Models.Intermediate.PackagesVersionInfo.VersionInfo>(StringComparer.OrdinalIgnoreCase);
                            result.Add(row.Id, versions);
                        }

                        var versionInfo = new Models.Intermediate.PackagesVersionInfo.VersionInfo
                        {
                            IsListed = row.IsListed == true,
                            IsLatest = row.IsLatest == true,
                        };
                        versions.Add(row.Version, versionInfo);
                    }
                });

            var intermediate = result.ToDictionary(
                kvp => kvp.Key,
                kvp => new Models.Intermediate.PackagesVersionInfo.VersionList
                {
                    Count = kvp.Value.Count,
                    Versions = kvp.Value.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase)
                });

            var final = new Models.Intermediate.PackagesVersionInfo
            {
                Count = intermediate.Count,
                Packages = intermediate.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase),
            };

            await WriteAsync(
                App.GetIntermediatesFileName(dataDirectory.FullName, App.Containers.PackageVersions),
                final,
                fileGroups.PackageVersions.Max(f => f.LastModified).UtcDateTime);
        }

        public static async Task WriteAsync<T>(string fileName, T data, DateTime timeStamp)
        {
            string directoryName = Path.GetDirectoryName(fileName) ?? throw new ArgumentException(paramName: nameof(fileName), message: "Could not get parent directory");
            if (!Directory.Exists(directoryName))
            {
                Directory.CreateDirectory(directoryName);
            }

            using (var fileStream = File.OpenWrite(fileName))
            using (var brotliStream = new BrotliStream(fileStream, CompressionLevel.Optimal))
            {
                await JsonSerializer.SerializeAsync(brotliStream, data);
            }

            File.SetLastWriteTimeUtc(fileName, timeStamp);
        }

        private async Task ReadAndTransformCsv<TRow>(
            string dataDirectory,
            string containerName,
            ClassMap csvMap,
            ImmutableList<BlobFile> inputFiles,
            string outputFile,
            Action<List<TRow>> accumulate
            )
        {
            if (csvMap.ClassType != typeof(TRow))
            {
                throw new ArgumentException($"Class map type {csvMap.ClassType} does not match input type {typeof(TRow)}");
            }

            var concurrentBlockOptions = new ExecutionDataflowBlockOptions
            {
                MaxDegreeOfParallelism = Environment.ProcessorCount,
            };
            var transformBlock = new TransformBlock<(ClassMap, string), List<TRow>>(ReadCsvFile, concurrentBlockOptions);

            var singleThreadOptions = new ExecutionDataflowBlockOptions
            {
                MaxDegreeOfParallelism = 1,
            };
            var accumulateBlock = new ActionBlock<List<TRow>>(accumulate, singleThreadOptions);

            var link = transformBlock.LinkTo(accumulateBlock, new DataflowLinkOptions { PropagateCompletion = true });

            foreach (var file in inputFiles)
            {
                var fileName = App.GetInsightsFileName(dataDirectory, containerName, file.Name);
                await transformBlock.SendAsync((csvMap, fileName));
            }

            transformBlock.Complete();
            await accumulateBlock.Completion;

            static List<TRow> ReadCsvFile((ClassMap csvMap, string fileName) input)
            {
                using (var fileStream = File.OpenRead(input.fileName))
                using (var gzipStream = new GZipStream(fileStream, CompressionMode.Decompress))
                using (var textStream = new StreamReader(gzipStream))
                {
                    var config = new CsvConfiguration(CultureInfo.InvariantCulture)
                    {
                        HasHeaderRecord = true,
                    };
                    var reader = new CsvReader(textStream, config);
                    reader.Context.RegisterClassMap(input.csvMap);
                    var data = reader.GetRecords<TRow>().ToList();
                    return data;
                }
            }
        }
    }
}
